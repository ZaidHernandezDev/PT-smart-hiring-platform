from fastapi import FastAPI, Depends, HTTPException
from pydantic import BaseModel, Field
from typing import Optional
from sqlalchemy import create_engine, Column, Integer, String, DateTime
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, Session
from datetime import datetime

# SQLite Database
DATABASE_URL = "sqlite:///./candidates.db"
engine = create_engine(DATABASE_URL, connect_args={"check_same_thread": False})
SessionLocal = sessionmaker(bind=engine, autoflush=False, autocommit=False)

Base = declarative_base()

# SQLAlchemy Model
class Candidate(Base):
    __tablename__ = "candidates"

    id = Column(Integer, primary_key=True, index=True)

    # Step 1: Personal Information
    full_name = Column(String)
    age = Column(Integer)
    location = Column(String)
    availability = Column(String)
    start_date = Column(String)

    # Step 2: Contact Information
    email = Column(String)
    phone = Column(String)
    remote_experience = Column(String)
    portfolio_url = Column(String)
    salary_expectation = Column(String)

    # Step 3: Soft Skills
    teamwork = Column(Integer)
    time_management = Column(Integer)
    problem_solving = Column(Integer)
    adaptability = Column(Integer)
    communication = Column(Integer)
    autonomy = Column(Integer)
    english_level = Column(Integer)

    # Step 4: Technical Skills
    html_css = Column(Integer)
    javascript = Column(Integer)
    frameworks = Column(Integer)  # React, Layouting, Vue.js or Angular
    responsive_design = Column(Integer)
    git = Column(Integer)
    performance_optimization = Column(Integer)
    ui_ux = Column(Integer)
    api_integration = Column(Integer)
    debugging = Column(Integer)
    testing = Column(Integer)

    result = Column(Integer, default=None)  # 1 = suitable, 0 = not suitable
    created_at = Column(DateTime, default=datetime.utcnow)

Base.metadata.create_all(bind=engine)

# Pydantic Schema
class CandidateCreate(BaseModel):
    # Step 1
    full_name: str
    age: int
    location: str
    availability: str
    start_date: str

    # Step 2
    email: str
    phone: str
    remote_experience: str
    portfolio_url: Optional[str]
    salary_expectation: str

    # Step 3
    teamwork: int = Field(ge=1, le=10)
    time_management: int = Field(ge=1, le=10)
    problem_solving: int = Field(ge=1, le=10)
    adaptability: int = Field(ge=1, le=10)
    communication: int = Field(ge=1, le=10)
    autonomy: int = Field(ge=1, le=10)
    english_level: int = Field(ge=1, le=10)

    # Step 4
    html_css: int = Field(ge=1, le=10)
    javascript: int = Field(ge=1, le=10)
    frameworks: int = Field(ge=1, le=10)
    responsive_design: int = Field(ge=1, le=10)
    git: int = Field(ge=1, le=10)
    performance_optimization: int = Field(ge=1, le=10)
    ui_ux: int = Field(ge=1, le=10)
    api_integration: int = Field(ge=1, le=10)
    debugging: int = Field(ge=1, le=10)
    testing: int = Field(ge=1, le=10)

# Dependency
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# FastAPI app
app = FastAPI()

# Create candidate
@app.post("/candidates/")
def create_candidate(candidate: CandidateCreate, db: Session = Depends(get_db)):
    db_candidate = Candidate(**candidate.dict())
    db.add(db_candidate)
    db.commit()
    db.refresh(db_candidate)
    return db_candidate

# Get all candidates
@app.get("/candidates/")
def get_candidates(db: Session = Depends(get_db)):
    return db.query(Candidate).all()

# Update result
@app.put("/candidates/{candidate_id}/result")
def update_result(candidate_id: int, result: int, db: Session = Depends(get_db)):
    candidate = db.query(Candidate).filter(Candidate.id == candidate_id).first()
    if not candidate:
        raise HTTPException(status_code=404, detail="Candidate not found")
    candidate.result = result
    db.commit()
    return {"message": f"Result updated to {result}"}
